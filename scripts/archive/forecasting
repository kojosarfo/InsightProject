#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Sep 23 12:29:22 2019

@author: kojosarfo
"""

from __future__ import print_function
from IPython.display import display
from ipywidgets import interact, interactive, fixed, interact_manual
from sklearn.model_selection import TimeSeriesSplit
import ipywidgets as widgets
import folium
import tensorflow as tf
from folium.plugins import HeatMap, HeatMapWithTime
import warnings
import pickle
import numpy as np
import pandas as pd
from datetime import datetime
from fbprophet import Prophet
#import numpy as np
import matplotlib.pyplot as plt
warnings.filterwarnings("ignore")
plt.style.use('fivethirtyeight')
import pandas as pd
#import statsmodels.api as sm
import matplotlib
from DataStructuring import get_data

#Some plot settings
matplotlib.rcParams['axes.labelsize'] = 14
matplotlib.rcParams['xtick.labelsize'] = 12
matplotlib.rcParams['ytick.labelsize'] = 12
matplotlib.rcParams['text.color'] = 'k'
plt.close('all')
pd.plotting.register_matplotlib_converters()


#This cell requires either the files: ('PedestriansData.sav' and 'CyclistsData.sav') or ('cycped_vol.csv' and 'weather.csv')
    
#filename = 'PedestriansData.sav'
#Pedestrians = pickle.load(open(filename, 'rb'))
#
#filename = 'CyclistsData.sav'
#Cyclists = pickle.load(open(filename, 'rb'))

Pedestrians, Cyclists, Locations = get_data()

#def multivariate_data(dataset, target, start_index, end_index, history_size, target_size):
#    
#    data = []
#    labels = []
#    
#    start_index = start_index + history_size
#    
#    if end_index is None:
#        end_index = len(dataset) - target_size
#        
#    print(start_index)
#    print(end_index)
#        
#    for i in range(start_index, end_index):
#        indices = range(i-history_size, i)
#        data.append(dataset[indices])
#        #print('Sarfo')
#    
#        labels.append(target[i:i+target_size])
#    
#    print(np.array(data))
#    
#    return np.array(data), np.array(labels)
#%%
def get_forecast(RoadUserID, IntID, testStart, testEnd, Horizon):
    print("This may take a while...\n\n")
    
    if RoadUserID == 1:
        X = Pedestrians
    elif RoadUserID == 2:
        X = Cyclists

    TrainSize = 24*7*4;
    trainStart = testStart - pd.Timedelta(hours = TrainSize)
    trainEnd = testStart - pd.Timedelta(hours = 1)

    Peds = X[IntID];
    trainVolume = Peds[trainStart: trainEnd]['volume'];
    
    #%% LSTM
    dataset = Peds[['volume','tempC','FeelsLikeC','humidity',
                  'cloudcover','windspeedKmph','visibility']].values
    
    data_mean=dataset.mean(axis=0)
    data_std=dataset.std(axis=0)
    
    dataset = (dataset-data_mean)/data_std
    
    start_index = Peds.index.get_loc(testStart)

    end_index = Peds.index.get_loc(testEnd)
    
    history_size = TrainSize;
    
    target_size = Horizon;
    
    
    data = []
    labels = []
    
    target = dataset[:,0]
    
    start_index = start_index + history_size
    
    if end_index is None:
        end_index = len(dataset) - target_size
        
    print(start_index)
    print(end_index)
        
    for i in range(start_index, end_index):
        indices = range(i-history_size, i)
        data.append(dataset[indices])
        #print('Sarfo')
    
        labels.append(target[i:i+target_size])
    
    print(data)
    x_train_multi = np.array(data);
    y_train_multi = np.array(labels);
    
    
    
#    x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:,0], start_index,
#                                                 end_index, TrainSize,
#                                                 Horizon)
#    x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, 0],
#                                             end_index, None, TrainSize,
#                                             Horizon) #end_index is the start_index for validation
    
    #%%

    testVolume = Peds[testStart: testEnd]['volume'];
    weatherForecast = Peds[trainStart: testEnd][['tempC','FeelsLikeC',
    'humidity','cloudcover','windspeedKmph','visibility']];

    pInput = Peds[trainStart: trainEnd][['dateTimeIdx','volume',
                 'tempC','FeelsLikeC','humidity','cloudcover',
                 'windspeedKmph','visibility']]
    pInput = pInput.rename(columns={"dateTimeIdx": "ds", "volume": "y"})

    #Using Prophet
    m = Prophet(yearly_seasonality=False, weekly_seasonality=True, daily_seasonality=True);
    m.add_regressor('tempC')
    m.add_regressor('FeelsLikeC')
    m.add_regressor('humidity')
    m.add_regressor('cloudcover')
    m.add_regressor('windspeedKmph')
    m.add_regressor('visibility')
    m.add_country_holidays(country_name='Canada')
    m.fit(pInput)
    future = m.make_future_dataframe(periods = Horizon, freq = 'h');
    future['tempC'] = weatherForecast['tempC'].values
    future['FeelsLikeC'] = weatherForecast['FeelsLikeC'].values
    future['humidity'] = weatherForecast['humidity'].values
    future['cloudcover'] = weatherForecast['cloudcover'].values
    future['windspeedKmph'] = weatherForecast['windspeedKmph'].values
    future['visibility'] = weatherForecast['visibility'].values
    forecast = m.predict(future)
    #m.plot(forecast)

    forecast_mean = forecast['yhat'][-Horizon:];
    forecast_mean = round(forecast_mean); forecast_mean[forecast_mean<0] = 0;
    forecastVolume = pd.DataFrame(forecast_mean);
    #forecastVolume.rename(columns={'yhat': 'Predicted'})
    forecastVolume.index = testVolume.index
    forecastVolume=forecastVolume['yhat']

    forecast_ci= forecast[['yhat_lower','yhat_upper']][-Horizon:];
    forecast_ci = round(forecast_ci); forecast_ci[forecast_ci<0] = 0;
    pred_ci= pd.DataFrame(forecast_ci);
    pred_ci.index=testVolume.index

    ## Loading ARIMA model from disk
    #filename = 'finalized_model.sav'
    #results = pickle.load(open(filename, 'rb'))
    #
    #pred = results.get_prediction(start = testStart, end = testEnd)
    #pred_ci = pred.conf_int();
    #forecastVolume = pred.predicted_mean;
    #forecastVolume = round(forecastVolume); forecastVolume[forecastVolume<0] = 0;

    ax = trainVolume[-2*Horizon:].plot(label='Historical')
    testVolume.plot(ax=ax, label='Observed')
    forecastVolume.plot(ax=ax, label='Forecast')
    ax.fill_between(pred_ci.index,
                    pred_ci['yhat_lower'],
                    pred_ci['yhat_upper'], color='k', alpha=.2)
    ax.set_xlabel('Date')
    if RoadUserID == 1:  
        ax.set_ylabel('Pedestrian volume')
    elif RoadUserID == 2:
        ax.set_ylabel('Cyclist volume')
        
    plt.legend()
    plt.show()
    
    return x_train_multi, y_train_multi, dataset

##%% Prophet Forecasting
#def ProphetForecast(trafficVolume, testStart, testEnd, Horizon):
#    
#    tscv = TimeSeriesSplit(n_splits=10, max_train_size = 24*7*4)
#    
#    trainVolume = trafficVolume[trainStart: trainEnd]['volume']
#
#    testVolume = Peds[testStart: testEnd]['volume'];
#    weatherForecast = Peds[trainStart: testEnd][['tempC','humidity']];
#
#    pInput = Peds[trainStart: trainEnd][['dateTimeIdx','volume',
#                 'tempC','humidity']]
#    pInput = pInput.rename(columns={"dateTimeIdx": "ds", "volume": "y"})
#    
#    
#    #Using Prophet
#    m = Prophet(yearly_seasonality=False, weekly_seasonality=True, 
#                daily_seasonality=True);
#    m.add_regressor('tempC')
#    m.add_regressor('FeelsLikeC')
#    m.add_regressor('humidity')
#    m.add_regressor('cloudcover')
#    m.add_regressor('windspeedKmph')
#    m.add_regressor('visibility')
#    m.add_country_holidays(country_name='Canada')
#    m.fit(pInput)
#    future = m.make_future_dataframe(periods = Horizon, freq = 'h');
#    future['tempC'] = weatherForecast['tempC'].values
#    future['humidity'] = weatherForecast['humidity'].values
#    forecast = m.predict(future)
    
    

#%%

RoadUserID = 1; IntID = 0;

testStart = pd.to_datetime('2019-06-26 00:00:00');

Horizon = 24; 

testEnd = testStart + pd.Timedelta(hours=Horizon-1);

x_train_multi, y_train_multi, dataset= get_forecast(RoadUserID, IntID, testStart, testEnd, Horizon)









