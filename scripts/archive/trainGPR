#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Sep 25 12:21:31 2019

@author: kojosarfo
"""

from __future__ import print_function
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.gaussian_process import GaussianProcessRegressor as gpr
from sklearn.gaussian_process.kernels import RBF
import warnings
import pickle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.close('all')

warnings.filterwarnings("ignore")
#%%
filename = 'stackedPeds.pickle'
trainPeds = pickle.load(open(filename, 'rb'))

filename = 'stackedCycs.pickle'
trainCycs = pickle.load(open(filename, 'rb'))

filename = 'Locations.sav';
Locations = pickle.load(open(filename, 'rb'))

filename = 'PedestriansData.sav'
Pedestrians = pickle.load(open(filename, 'rb'))

filename = 'CyclistsData.sav'
Cyclists = pickle.load(open(filename, 'rb'))

#%%
filenames = ['gprPedsMdl.pickle', 'gprCycsMdl.pickle']
yLabels = ['Pedestrian volume','Cyclist volume']

#%%

trainData = [trainPeds, trainCycs]
for i in range(2):
    
    print(i)
    
    trafficData = trainData[i]
    
    trafficData = trafficData.dropna()
    
    X = trafficData[['Hour','DayOfWeek','isHoliday','lat','lng']]
    
    Y = trafficData['volume']
    
    X_train, X_test, y_train, y_test = \
    train_test_split(X, Y, test_size=0.2, random_state=0)
    
    scalerObj = StandardScaler()
    scalerObj.fit(X_train)
    
    X_train_scaled = scalerObj.transform(X_train)
    
    kernel = RBF(length_scale=np.ones([5,]))
    gprMdl = gpr(kernel=kernel, random_state=0, normalize_y=True, 
                 n_restarts_optimizer = 0).fit(X_train_scaled, y_train)
    
    filename = filenames[i]
    with open(filename, 'wb') as handle:
        pickle.dump(gprMdl, handle, protocol=pickle.HIGHEST_PROTOCOL)
               
    # Validation  
    X_test_scaled =  scalerObj.transform(X_test)
    yPred, yStd = gprMdl.predict(X_test_scaled, return_std=True)
    yPred = yPred.astype('int'); yPred[yPred<0]=0
    
    yPred = pd.DataFrame(yPred, columns =['forecast']); 
    yPred.index = y_test.index; yPred = yPred['forecast'];
    
    yLow = yPred - 3*yStd; yLow = yLow.astype('int'); yLow[yLow<0]=0
    yHigh = yPred + 3*yStd; yHigh = yHigh.astype('int');
    
    xIndex = np.arange(0,len(y_test))
    
    plt.figure(i+1)
    plt.plot(xIndex, y_test.values, 'ro', label = 'Observed')
    plt.plot(xIndex, yPred.values, 'bo', label ='Predicted')
    plt.ylabel(yLabels[i])
    plt.xlabel('Random time/intersection instances')
    plt.show()
    
    print('RMSE: '+str(np.sqrt(np.mean((yPred.values - y_test.values)**2))))
    print('R_Squared: '+str(gprMdl.score(X_test, y_test)))
    

#%% Validation in terms of hold-out intersections

IntersectionNames = ['Richmond-Bay', 'Wellington-Blue_jays',
                     'Wellington-Bay', 'King-John'];
RoadUser = ['Pedestrians', 'Cyclists']

trafficData = [Pedestrians, Cyclists]

filename = 'gprPedsMdl.pickle'
gprPedsMdl = pickle.load(open(filename, 'rb'))

filename = 'gprCycsMdl.pickle'
gprCycsMdl = pickle.load(open(filename, 'rb'))

gprMdls = [gprPedsMdl, gprCycsMdl]

testStart = pd.to_datetime('2019-07-01 00:00:00');
testEnd = pd.to_datetime('2019-07-31 23:00:00');

for j in range(2):
    
    gprMdl = gprMdls[j]
    
    testData = trafficData[j]
    for k in range(4): #Intersection IDs: 10,11,12,13
        
        testIntersection = testData[k+10];
        
        testIntersection = testIntersection[testStart: testEnd]
            
        testIntersection = testIntersection.dropna()
        
        X = testIntersection[['Hour','DayOfWeek','isHoliday']];
        
        X['lat'] = np.ones([len(X),1])*Locations.iloc[k,0]
        X['lng'] = np.ones([len(X),1])*Locations.iloc[k,1]
        
        X_test = X
        
        X_test_scaled = scalerObj.transform(X_test)
        
        y_test = testIntersection['volume']
        
        yPred, yStd = gprMdl.predict(X_test_scaled, return_std=True)
        yPred = yPred.astype('int'); yPred[yPred<0]=0
        
        yPred = pd.DataFrame(yPred, columns =['forecast']); 
        yPred.index = y_test.index; yPred = yPred['forecast'];
        
        yLow = yPred - 3*yStd; yLow = yLow.astype('int'); yLow[yLow<0]=0
        yHigh = yPred + 3*yStd; yHigh = yHigh.astype('int');
        
        xIndex = np.arange(0,len(y_test))
               
        plt.figure(11+j+k)
        ax = y_test.plot(label = 'Observed')
        yPred.plot(ax = ax, label = 'Predicted')
        ax.fill_between(y_test.index,
                            yLow,
                            yHigh, color='k', alpha=.2)
        ax.set_xlabel('Time')
        ax.set_ylabel(RoadUser[j]+ ' volume')
        ax.set_title(IntersectionNames[k]+ ' Intersection')
        plt.legend()
        plt.show()
        
        print('RMSE: '+str(np.sqrt(np.mean((yPred.values - y_test.values)**2))))
        print('R_Squared: '+str(gprMdl.score(X_test, y_test)))